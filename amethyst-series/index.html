<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>doomy</title>
    <meta name="description" content="Playing around with Amethyst, an ECS-based game engine for the Rust programming language">

    
    

    
<meta property="og:title" content="Experimenting with Amethyst: A Rust game engine">
<meta property="og:description" content="Playing around with Amethyst, an ECS-based game engine for the Rust programming language">
<meta property="og:url" content="https:&#x2F;&#x2F;doomy.org&#x2F;amethyst-series&#x2F;">
<meta property="og:type" content="article">
<meta property="og:site_name" content="doomy">



    <!-- css -->
    <noscript>
        <style>
            .theme-switcher {
                display: none;
            }
        </style>
    </noscript>
    <link rel="stylesheet" href="/reset.css">
    <link rel="stylesheet" href="/feather.css">
    
    
    <link rel="stylesheet" href="/syntax-theme-light.css" media="screen" />
    <link rel="stylesheet" href="/syntax-theme-dark.css" media="screen and (prefers-color-scheme: dark)" />
    
    

    <link rel="stylesheet" id="syntax" />

    
    <script data-goatcounter=https://doomy-org.goatcounter.com/count async src="//gc.zgo.at/count.js"></script>
    

    
    <script></script>
    

    
    
</head>

<body >
    <div class="root">

        <nav>
            <div class="flex padded">
                <div class="flex fill vcenter">
                    <a href="/">
                        <h4>doomy</h4>
                    </a>
                </div>
                
                <button class="theme-switcher"></button>
                
            </div>
            
            <div class='header-image' style='background-image: url(/theme_images/default.gif);'>
            </div>
            
        </nav>



        
<div class='container'>
	<section class="post">
		<div class="title-and-info">
			<h2>Experimenting with Amethyst: A Rust game engine</h2>
			<div class="info">
				<span>2019 Jun 10</span>

				
                    <span class='divider' />
                    <a href="https:&#x2F;&#x2F;mastodon.social&#x2F;@doomy" target="_blank">@doomy@mastodon.social</a>
				

				
			</div>
		</div>
		<article>
			
			
			
			

			


			<p>It's been a while! I haven't been not-busy, but writing is effort, u kno?</p>
<p>Well to make up for that, I'm going to be documenting progress using &amp; learning the Amethyst game engine.</p>
<h2 id="amethyst">Amethyst</h2>
<p>So, what is Amethyst? <a rel="noopener" target="_blank" href="https://amethyst.rs/">It's a game engine</a> written with the Rust programming language. I've been involved as a volunteer since winter, and I've been learning the engine itself more and more each day.</p>
<p>Hopefully by documenting my progress here, I can document early issues I ran into, and how to solve them.</p>
<h2 id="game">Game</h2>
<p>To be honest, I don't really have that perfectly nailed down right now. My goal is to just make <em>something</em> that I can build off of. At first, I tried a simple DDR/FFR style rhythm game. This was a great exercise, but it was so messy by the time I was done with it (probably a good sign I learned a lot).</p>
<h2 id="starting-out">Starting out</h2>
<p>Amethyst is built on <code>specs</code>, an ECS (Entity Component System). If you've used something like Unity in the past, you might be partially familiar.</p>
<p>I thought it'd be smooth sailing, since I <em>had</em> used Unity in the past, and ECS was a term I was comfortable with. For the most part it was - however, Unity's "ECS" has a few distinct differences.</p>
<p>In Unity, when you want to write a new script, you often use <code>MonoBehaviour</code>. This file would contain a definition of the component, as well as how that individual component should behave.</p>
<p>In Amethyst, we see the "S" in "ECS" more often. Instead of having a component describe its own implementation, we use Systems. While I won't go into depth about the topic since the <a rel="noopener" target="_blank" href="https://amethyst.rs/doc">Amethyst book covers these topics much better than I could</a>, let me give you a general gist of systems.</p>
<p>Whereas some engines like Unity define individual implementation, systems define how <em>all</em> things of a certain type should behave. This makes it super easy to benefit from certain CPU performance improvements later on.</p>
<h2 id="hurdles">Hurdles</h2>
<p>Okay. When I said my first game attempt in Amethyst was an FFR clone, I lied. It was actually going to be a text-based visual novel. As is often the case with game development, I planned a huuuge scope while I was still learning. Turns out this is usually not a good idea! My first lesson is don't even <em>pretend</em> like the first few games you make while learning an engine will last. It's important to be messy, make mistakes, learn, and move on.</p>
<p>So that brings us to our FFR style game. The idea was to create something <em>much</em> simpler. The game would start with a song at a constant BPM, a file would describe what "arrows" would show, and input was limited to keyboard movements. While I never attained this goal either, I actually got kind of far! If you'd like to take a look, I have the <a rel="noopener" target="_blank" href="https://github.com/piedoom/r">hideous messy source code right here</a>. So, I got the arrows spawning according to a timer, and moving down at a constant speed. Input is also captured, although it has no outward effect on the "game".</p>
<p>So, why did I move on, and what did I learn? My biggest issue was figuring out which code should be put in a <code>Component</code>, and which code should be put in a <code>System</code>. For instance, if I want to move an entity with a component, I also need the entity's transform. Should a function be supplied in the component that takes a reference to a transform, or should everything be handled in the system?</p>
<p>To illustrate the difference, imagine the following pseudo-code:</p>
<pre data-lang="rs" class="language-rs z-code"><code class="language-rs" data-lang="rs"><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Component 
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">MyComponent</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    speed: 1
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">impl MyComponent
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    fn move_up</span><span class="z-meta z-struct z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>self, transform</span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> 
</span><span class="z-source z-rust">        <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> move up the transform here using the component speed
</span></span><span class="z-source z-rust">        transform<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">move_up</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-language z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span>speed</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> System
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">MyComponentSystem</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">impl MyComponentSystem
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    fn run</span><span class="z-meta z-struct z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>component, transform</span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span><span class="z-source z-rust">        component<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">move_up</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>transform</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></code></pre>
<p>Here, we define data <em>and</em> implementation in a component. After playing around with my code, I found similarities to ECS and other common patters like MVC. Compared to MVC, components are almost like models, in that they contain data (and possibly some helper functions), but do not implement their own functionality. That is left up to the system (which is similar ((sort of)) to a controller).</p>
<p>So if we were to rewrite the above pseudo-code, it might look like this:</p>
<pre data-lang="rs" class="language-rs z-code"><code class="language-rs" data-lang="rs"><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Component 
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">MyComponent</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    speed: 1
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> System
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">struct MyComponentSystem
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">impl MyComponentSystem
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    fn run</span><span class="z-meta z-struct z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>component, transform</span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span><span class="z-source z-rust">        <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> imagine the transform component has a translate_up function
</span></span><span class="z-source z-rust">        transform<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">translate_up</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>component<span class="z-punctuation z-accessor z-dot z-rust">.</span>speed</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></code></pre>
<p>It does the same thing, but implementing most of the logic in a system makes it easier to keep track my project's code.</p>
<h2 id="what-s-next">What's Next</h2>
<p>Now that I had working knowledge of how to use specs, I thought it was a good idea to start fresh and new. I wanted to come back to the idea of basing a game around a narrative. Unfortunately, text-based graphics - while not difficult - are not relatively popular, which means I'd have less resources from which to learn. Instead, I thought a top-down JRPG-like game might be a bit more attainable. Okay, actually JRPGs are super hard, but the movement aspect is easy.</p>
<p>For JRPG/Pokemon style movement, a character needs to be able to move in at least the four cardinal directions, align itself to a grid, and not run through walls.  This is <em>much</em> simpler than attempting something like a platformer which gets hairy for someone with a BFA, especially when slopes are involved. I'm a horror fan, and I think there's a criminal lack of 2D horror - so I've decided to make an RPG-like horror game. Fun stuff!</p>
<h2 id="movement">Movement</h2>
<p>Okay, so lets remember the 3 goals from earlier:</p>
<ol>
<li>Move in four directions</li>
<li>Align to a grid</li>
<li>Don't run through walls</li>
</ol>
<p>I have a solid 2 / 3 so far, which I think is pretty good! My character runs around in an endless cornflower-blue void, but it's a start.</p>
<h3 id="1-move-in-four-directions">1. Move in four directions</h3>
<p>To start, I needed a way to move the character. Sometimes, just modifying a transform in a system would suffice, but in my case, I knew I had more advanced movement in the future, so I opted for custom components. I created two, actually - <code>Movement</code>, and <code>Player</code>. This way, I can re-use my movement component with NPCs and other game entities without it being tied to game input. Instead, my <code>Player</code> component and system capture user input, and modify a <code>Movement</code> state. The movement system <em>then</em> moves everything based on the component's state.</p>
<p>Again, as someone whose degree includes the word "Art", math is not my forte. I actually regret not paying attention in my classes. Ever hear people say "when will I ever use this?" in class? Well, you will use it. Probably a lot. At least if you are an aspiring game developer.</p>
<p>However, I watched a few videos on vectors and all that cool stuff, so I got a #solid grasp on some concepts. This helped a lot when figuring out how to keep the direction state in my <code>Movement</code> component.</p>
<p>Usually, I would do something like this to store direction:</p>
<pre data-lang="rs" class="language-rs z-code"><code class="language-rs" data-lang="rs"><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Movement</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    up: bool
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    down: bool
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    left: bool
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    right: bool
</span></span></code></pre>
<p>While not totally awful (maybe a little awful), it is not ideal, especially when dealing with vector math later down the road. Instead, the nalgebra math crate provides me with a <code>Vector3</code>, and a <code>Unit</code> type.</p>
<p>From my light reading, I realized I could store the direction of my <code>Movement</code> in a unit vector.</p>
<pre data-lang="rs" class="language-rs z-code"><code class="language-rs" data-lang="rs"><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Movment</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust">    direction: Unit&lt;Vector3&gt;
</span></span></code></pre>
<p>This makes it super-duper simple to actually use this value later on in tandem with the entity transform.</p>
<h3 id="2-align-to-a-grid">2. Align to a grid</h3>
<p>This one was much tougher for me! I had a few ideas on how to implement grid-based movement. Initially, I just <code>lerp</code>ed between two values via the <code>Movement</code> component. This is great for entities that only move one grid at a time. However, for entities that move multiple tiles in one direction, this method looked unstable and jittery. Controls also felt unresponsive sometimes.</p>
<p>Instead, I figured that I only really care if the entity is aligned to a grid <em>before</em> and <em>after</em> it stops moving. In-between, it can just y'know, go. I haven't implemented this yet, but it should allow for smoother movement and tighter-feeling controls.</p>
<h3 id="3-don-t-run-through-walls">3. Don't run through walls</h3>
<p>This is the hardest part, in my mind. It should be decently simple - since all items are aligned to a grid, all we would need to do is check if the tile next to the player is empty. However, this (possibly) gets into ray-casting which I'm unfamiliar with using Amethyst. But I hope to learn!</p>
<h2 id="end">End</h2>
<p>All said, while I did struggle a bit with the initial complexity, Amethyst is an insanely fun engine to work with, even if all you're doing is making sprites move around. Specs is very powerful, and the "composition over inheritance" style of coding makes development go much quicker than I expected.</p>
<p>I hope to have more stuff like this in the future! Please consider <a rel="noopener" target="_blank" href="https://amethyst.rs/donate/">donating</a> to the Amethyst Foundation to support development.</p>
<hr />
<p>Last week I took a deep dive into Amethyst, and learned as much as I could in a week. I figured out systems, got a player moving with input, and created a component for grid-aligned movement. As a quick update, let's talk about the movement system:</p>
<h2 id="review">Review</h2>
<p>In the previous issue, I created both a <code>GridMovement</code> component, as well as a <code>Movement</code> component. The latter was free-er and not aligned to a grid like the former. In the future if I were to redesign this, I would create one single movement component, as well as a <code>GridAligned</code> component. Because grid calculations are significantly different than simple free-moving calculations, this separate component would keep the necessary data to feed into the regular movement component. Alternatively, an "align to grid" boolean option on a <code>Movement</code> component could prove to be a simpler solution.</p>
<h2 id="this-week">This week</h2>
<p>This week was all about maps! Specifically, <a rel="noopener" target="_blank" href="https://www.mapeditor.org/">Tiled</a> - a 2D tilemap editor with a wide array of supported game engines. Tiled encodes its data in XML, which is convenient since it means a custom parser doesn't need to be implemented.</p>
<h2 id="tiled">Tiled</h2>
<p>Rust actually has a crate for Tiled, called <a rel="noopener" target="_blank" href="https://github.com/mattyhall/rs-tiled"><code>rs-tiled</code></a>. It's somewhat barebones, but provides everything I needed to get started. (Well, almost everything, but more on that later.) There's also a great beginner example of how to use <code>rs-tiled</code> within Amethyst, <a rel="noopener" target="_blank" href="https://github.com/Temeez/Tiled-Amethyst-Example">which you can view here</a>.</p>
<p>There's a few limitations with the above:</p>
<ol>
<li>The tilemap is not loaded as an asset, as a spritesheet or model would be. This means it's quick and easy to load via our world, but can pose some issues later on if we want to read our map data in other systems.</li>
<li>The example only loads a single layer, which is too basic for a JRPG-style game. We will eventually want not only a background layer, but a scenery layer.</li>
</ol>
<p>I sought out to create an asset type from <code>rs-tiled</code> according to the guide <a rel="noopener" target="_blank" href="https://book.amethyst.rs/master/assets/how_to_define_custom_assets.html">available here</a>. It's relatively straightforward, especially since <code>rs-tiled</code> provides a method to read from bytes.</p>
<p>Not exactly Amethyst related, but I dislike when Rust projects try to put too much in a single file.While I'm grateful that <code>rs-tiled</code> exists, all of the code was in a single <code>lib.rs</code> file which made understanding it rather difficult. Additionally, the code was not Rust 2018 idiomatic, mostly because it used the <code>try!</code> macro instead of the preferred <code>?</code> for <code>Result</code>s.</p>
<p><a rel="noopener" target="_blank" href="https://github.com/piedoom/rs-tiled">To remedy this, I created my own fork of <code>rs-tiled</code></a>, which updates the code so newer <code>rustc</code> won't complain. I also added an <code>amethyst</code> feature gate that enables <code>Map</code> to be an asset. This worked pretty great, actually! I'm not sure if including the asset type within the crate is idiomatic, but once that is reviewed I might muster up the courage to PR into master - though depending on the original author's intentions they may not like my very subjective splitting up of source files.</p>
<h2 id="building-the-map">Building the Map</h2>
<p>This was the <em>really</em> tough part for me. Now that I had a <code>Map</code> asset, how do I use it? My first thought was "Oh, well, a handle is just like a reference, right? All I have to do is dereference that handle somehow to get the underlying asset! Easy."</p>
<p>Okay, so let's try it. In Amethyst, we get the underlying asset of a <code>Handle</code> like this:</p>
<pre data-lang="rs" class="language-rs z-code"><code class="language-rs" data-lang="rs"><span class="z-source z-rust">asset_storage<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">get</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-operator z-bitwise z-rust">&amp;</span><span class="z-variable z-language z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span>my_handle<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">clone</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">unwrap</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<p>Annnnd... it panics! But why?</p>
<p><code>Handle</code>s are returned <em>immediately</em> from a <code>load</code> method, as to not block the game thread. This means that the <code>Handle</code> could point to data that is not yet fully loaded. When we try to get this incomplete data, the program panics.</p>
<p>While I struggled for a while to understand this concept, it's relatively easy in retrospect. The solution to make sure that everything is loaded before continuing. We can do this with <code>ProgressCounter</code>s and states.</p>
<p>From a high level, our program flow looks like this:</p>
<pre class="z-code"><code><span class="z-text z-plain">Game Start -&gt;
</span><span class="z-text z-plain">Begin Loading State -&gt;
</span><span class="z-text z-plain">    Load Map
</span><span class="z-text z-plain">    Every Update, check if Map is loaded
</span><span class="z-text z-plain">    If loaded, push new state with Map handle
</span><span class="z-text z-plain">Push Main Game State -&gt;
</span><span class="z-text z-plain">    Main Game State has Map handle field
</span><span class="z-text z-plain">    This handle is guaranteed to be fully loaded
</span></code></pre>
<p>Actually not too bad! This has the benefit of accidentally creating a nice loading state for us to use in our game.</p>
<p>If you want to see the full details of how I actually did this, <a rel="noopener" target="_blank" href="https://github.com/piedoom/j/blob/master/src/states/load.rs#L20">take a look at my code here</a>. Note that I actually use a couple loading states, since my map file contains references to textures that need to be loaded.</p>
<p>Awesome. Our map is loaded and ready to use. All that's left is to build it. To do this, I used Temeez's aforementioned <a rel="noopener" target="_blank" href="https://github.com/Temeez/Tiled-Amethyst-Example">Amethyst-Tiled</a> example as a base. Every tile in this case is a separate entity. While that might seem like a lot, entities in Amethyst are extremely cheap, so there's not much to worry about performance wise.</p>
<h3 id="system-data">System Data</h3>
<p>Systems, as we know, are designed to manage the behavior of a lot of <em>things</em> every game update. While we need functionality similar to this, our map building function only needs to run <em>once</em>, which makes running the code in the <code>on_start</code> of a game state more fitting. We can get the best of both worlds by using <code>world.exec</code> in our game state with system data.</p>
<p>I'm by no means an expert <code>borrowck</code> charmer, so I may have made newbie errors, but using <code>SystemData</code> instead of a bunch of method calls on <code>world</code> helped me avoid a lot of borrow check issues. I won't get into the weeds, <a rel="noopener" target="_blank" href="https://github.com/piedoom/j/blob/master/src/states/main.rs#L35">but here's the code again if you're interested</a>. Take note that building the map would probably be more suitable to be done in yet another loading state.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>Great! We have a way to read our tiled file, a state to load all its resources, and then a main state to actually build the tilemap and run the game. And just like that, my blobby red player sprite is no longer drifting in an endless blue void.</p>
<p><img src="https://doomy.org/amethyst-series/mwia2.png" alt="" /></p>
<h2 id="next-up">Next Up</h2>
<p>I'll be honest, this learning experience took a lot out of me. I might take a small break to a small non-tilemap-based program for a bit, but after that my next goal is collision. There's already an nphysics integration for Amethyst, and I'm excited to try it out! Until next time.</p>
<hr />
<p>This week, I worked on something new for a change of pace.</p>
<video width="100%" controls>
    <source src="fixed.mp4" type="video/mp4">
    Your browser does not support the video tag.
</video>
<h1 id="new-things">New Things</h1>
<p>Yeah, I know. <em>Another</em> new thing. It's fine though, I'm not too attached. This is all about learning, and I'm going to continue to try.</p>
<p>I wanted to create a asteroids-style movement game based roughly on the base building mechanics of my favorite MMO growing up, <a rel="noopener" target="_blank" href="https://www.starsonata.com/">Star Sonata</a>.</p>
<p>This game has different ships, which can be customized with different engines, radars, weapons, and more. Sounds like a great opportunity to learn about prefabs, right?</p>
<h1 id="prefabs">Prefabs</h1>
<p>Well, I finally did it! I delved into prefabs. They are unfortunately one of the more confusing and complex parts of Amethyst. Once you get the hang of them, though, they aren't too bad. However, this area is definitely one where Amethyst can improve (and it should improve once <a rel="noopener" target="_blank" href="https://github.com/amethyst/atelier-assets">Atelier Assets</a> lands).</p>
<h2 id="a-short-explaination">A short explaination</h2>
<p>Prefab data is just a struct with a ton of optional fields. This is really the only important part of prefabs, the rest is (again, unfortunately) boilerplate.</p>
<p>An example prefab definition:</p>
<pre data-lang="rs" class="language-rs z-code"><code class="language-rs" data-lang="rs"><span class="z-source z-rust"><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">derive</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">Deserialize<span class="z-punctuation z-separator z-rust">,</span> Serialize<span class="z-punctuation z-separator z-rust">,</span> PrefabData</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span><span class="z-source z-rust"><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">serde</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">deny_unknown_fields</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">EntityPrefabData</span> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">name</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>Named<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">mesh</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span><span class="z-meta z-generic z-rust">MeshPrefab<span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>GenMeshVertex<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span><span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">material</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>MaterialPrefab<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">gltf</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span><span class="z-meta z-generic z-rust">AssetPrefab<span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>GltfSceneAsset, GltfSceneFormat<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span><span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">camera</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>CameraPrefab<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">transform</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>Transform<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">light</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>LightPrefab<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">player</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span><span class="z-meta z-path z-rust">c<span class="z-punctuation z-accessor z-rust">::</span></span>Player<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">controller</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span><span class="z-meta z-path z-rust">c<span class="z-punctuation z-accessor z-rust">::</span></span>Controller<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre>
<p>So why the options? Well, currently there is a limitation where multiple prefab definitions in a <code>ron</code> file must have homogenous data (though it's gotten <a rel="noopener" target="_blank" href="https://github.com/amethyst/amethyst/pull/1625">some improvements</a> since I started).</p>
<h2 id="making-prefabs-useful">Making prefabs useful</h2>
<p>I heavily stole from Amethyst's showcase project, <a rel="noopener" target="_blank" href="https://github.com/amethyst/evoli">Evoli</a> - specifically its <a rel="noopener" target="_blank" href="https://github.com/amethyst/evoli/blob/master/src/resources/prefabs.rs">prefab resource</a>. This code inserts all prefabs in a given folder into a hashmap, and then inserts itself as a resource. That lets us in turn build more data-driven games.</p>
<h1 id="movement-1">Movement</h1>
<p>My movement is... O.K. It turns out that Asteroids-style thrust movement isn't as easy as it would seem, especially when all resources on the internet talk about how to do so using a physics system, which I wanted to avoid for now.</p>
<p>However, I came up with a decent interim solution.</p>
<pre data-lang="rs" class="language-rs z-code"><code class="language-rs" data-lang="rs"><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> rotate based on unit points
</span></span><span class="z-source z-rust">transform<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">append_rotation_z_axis</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> This will orient the rotation direction correctly
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    controller<span class="z-punctuation z-accessor z-dot z-rust">.</span>rotation_control <span class="z-keyword z-operator z-arithmetic z-rust">*</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Multiply by our turn speed, which is just a multiplier.
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-meta z-path z-rust">Float<span class="z-punctuation z-accessor z-rust">::</span></span>from<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>controller<span class="z-punctuation z-accessor z-dot z-rust">.</span>turn_speed</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">*</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Finally, multiply everything by our delta to keep consistent across framerates
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-meta z-path z-rust">Float<span class="z-punctuation z-accessor z-rust">::</span></span>from<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>time<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">delta_seconds</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Set thrust and velocity
</span></span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> this gets our facing direction
</span></span><span class="z-source z-rust"><span class="z-storage z-type z-rust">let</span> rotation <span class="z-keyword z-operator z-assignment z-rust">=</span> transform<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">isometry</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">inverse</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span>rotation<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">to_homogeneous</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-storage z-type z-rust">let</span> direction <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-meta z-path z-rust">Unit<span class="z-punctuation z-accessor z-rust">::</span></span>new_unchecked<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-path z-rust">Vector3<span class="z-punctuation z-accessor z-rust">::</span></span>new<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>rotation<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">row</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-other z-rust">UP</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-constant z-numeric z-integer z-decimal z-rust">0</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-punctuation z-separator z-rust">,</span> rotation<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">row</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-other z-rust">UP</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-meta z-path z-rust">Float<span class="z-punctuation z-accessor z-rust">::</span></span>from<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-float z-rust">0.</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> If our input is 0, we&#39;re not changing our velocity.
</span></span><span class="z-source z-rust"><span class="z-keyword z-control z-rust">if</span> controller<span class="z-punctuation z-accessor z-dot z-rust">.</span>thrust_control <span class="z-keyword z-operator z-comparison z-rust">!=</span> <span class="z-meta z-path z-rust">Float<span class="z-punctuation z-accessor z-rust">::</span></span>from<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-float z-rust">0.</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    controller<span class="z-punctuation z-accessor z-dot z-rust">.</span>velocity <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-meta z-path z-rust">Unit<span class="z-punctuation z-accessor z-rust">::</span></span>new_normalize<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        controller<span class="z-punctuation z-accessor z-dot z-rust">.</span>velocity<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">as_ref</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> direction<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">scale</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>controller<span class="z-punctuation z-accessor z-dot z-rust">.</span>thrust_control <span class="z-keyword z-operator z-arithmetic z-rust">*</span> controller<span class="z-punctuation z-accessor z-dot z-rust">.</span>acceleration</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Finally, actually transform, multiplying by our max speed and delta
</span></span><span class="z-source z-rust">transform<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">prepend_translation</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    controller
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">        <span class="z-punctuation z-accessor z-dot z-rust">.</span>velocity
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">        <span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">scale</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>controller<span class="z-punctuation z-accessor z-dot z-rust">.</span>max_speed <span class="z-keyword z-operator z-arithmetic z-rust">*</span> <span class="z-meta z-path z-rust">Float<span class="z-punctuation z-accessor z-rust">::</span></span>from<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>time<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">delta_seconds</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<p>You can see the whole thing <a rel="noopener" target="_blank" href="https://github.com/piedoom/s/blob/master/src/systems/controller.rs">in context here</a>. Please note this is by no means a very good solution, and I've already run into some issues with it cutting off important data.</p>
<h1 id="3d-rendering">3D Rendering</h1>
<p>This part is actually pretty easy. Again, I stole a bunch of code from the Rendy example, and then modified it to only provide the PBR pass (or so I think). You can see what I have so far at the top! It's rendering a plane, so it doesn't look 3D, but trust me - it is.</p>
<h1 id="next-week">Next Week</h1>
<p>Next, I'm hoping to do more with modeling practice, as well as figuring out prefabs better. See you there!</p>

			


		</article>
	</section>
	
	<div id="cusdis">
		
				<div id="cusdis_thread"
				style="background: none !important;"
				data-host="https://cusdis.com"
				data-app-id="aaae44f5-19b5-419e-88d9-9522e2617ece"
				data-page-id="https:&#x2F;&#x2F;doomy.org&#x2F;amethyst-series&#x2F;"
				data-page-url="amethyst-series"
				data-page-title="Experimenting with Amethyst: A Rust game engine"
				data-theme="auto"
				></div>
				<script async defer src="/js/cusdis.es.js"></script>
		
	</div>
</div>


        <footer>
            
            <p>
                Feather theme by <a href="https://doomy.org">doomy</a>&nbsp;&nbsp;-&nbsp;&nbsp; Built with <a
                    href="https://getzola.org">Zola</a>
            </p>
            
        </footer>
    </div>
    
    <script>
        function change_theme(theme) {
            if (theme == "light") {
                document.body.classList.remove("dark");
                document.body.classList.add("light");
                document.querySelector('#syntax').href = '/syntax-theme-light.css';
            } else if (theme == "dark") {
                document.body.classList.add("dark");
                document.body.classList.remove("light");
                document.querySelector('#syntax').href = '/syntax-theme-dark.css';
            }
            localStorage.setItem("theme", theme);
        }

        window.addEventListener('load', () => {
            // Select the button
            const theme = (function () {
                const stored = localStorage.getItem("theme");
                if (stored == "null") {
                    if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                        return "dark";
                    } else {
                        return "light";
                    }
                } else {
                    return stored;
                }
            })();

            change_theme(theme);

            // Listen for a click on the button
            document.querySelector(".theme-switcher").addEventListener("click", function () {
                if (!document.body.classList.contains("dark")) {
                    change_theme("dark");
                } else {
                    change_theme("light");
                }
            });

        });
    </script>
    
    <script src="/js/footnote.js"></script>
</body>

</html>
